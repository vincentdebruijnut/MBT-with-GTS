\section{Implementation}\label{sec:implementation}

This section features several implementation issues of GRATiS.

\subsection{Control program}
Make an interaction variable using $parin:$ node and control program $\mathit{alap} \{ \rule(n \in \mathbb{U}^\sort) | \mathit{other}\}$, where $\sort \in \Sorts$ is the sort of the interaction variable.

\subsection{Rule priority}
There can be several outgoing rule transitions from a graph. However, GROOVE can set different priority levels on rules. A rule transition with a higher priority rule is explored before rule transitions with lower priority rules. Consider the graph grammar in Figure~\ref{fig:priority_gg}. The 'add' rule produces a rule transition to a graph, where the 'sub' rule produces a rule transition back to the start graph. The 'sub' rule does not match the start graph, because it has a lower priority than the 'add' rule.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The start graph state]{\label{fig:priority_start}\input{./img/priority_start.tex}}\hspace{20px}
    \subfloat[The LHS of rule 'sub' with priority 1]{\label{fig:priority_lhs1}\input{./img/priority_lhs1.tex}}\hspace{20px}
    \subfloat[The RHS of rule 'sub' with priority 1]{\label{fig:priority_rhs1}\input{./img/priority_rhs1.tex}}\hspace{20px}
    \subfloat[The LHS of rule 'add' with priority 2]{\label{fig:priority_lhs2}\input{./img/priority_lhs2.tex}}\hspace{20px}
    \subfloat[The RHS of rule 'add' with priority 2]{\label{fig:priority_rhs2}\input{./img/priority_rhs2.tex}}
  \end{center}
  \caption{A control node and program in GROOVE}
  \label{fig:priority_gg}
\end{figure} 

The graphs are isomophic under the point algebra, so they represent the same location. The STS of transforming this graph grammar is in Figure~\ref{fig:priority_sts_wrong}, with $\imath = \{x \mapsto 25\}$. This STS is wrong, because the 'sub' switch relation can be taken from the start.

\begin{figure}[ht]
  \begin{center}
    \input{./img/priority_sts_wrong.tex}
  \end{center}
  \caption{A wrong STS transformation of the graph grammar in Figure~\ref{fig:priority_gg}}
  \label{fig:priority_sts_wrong}
\end{figure}

The solution is shown in Figure~\ref{fig:priority_sts_right}. The negated guard of the 'add' switch relation is added to the 'sub' switch relation. The optimized guard for this switch relation is 'x >= 30' of course, but this shows the main principle: for each outgoing switch relation, the negated guard of all switch relations represented by higher priority rules must be added to the guard. So, the 'x < 30' guard is negated to '!(x < 30)' and added to yield the 'x > 10 \&\& !(x < 30)' guard. Note that if the 'add' switch relation had no guard, it would be applicable on all graph states with isomorphic abstractions. Therefore, the 'sub' switch relation would not exist, because the 'add' rule is always applicable whenever the 'sub' rule also is.

\begin{figure}[ht]
  \begin{center}
    \input{./img/priority_sts_right.tex}
  \end{center}
  \caption{A correct STS transformation of the graph grammar in Figure~\ref{fig:priority_gg}}
  \label{fig:priority_sts_right}
\end{figure}
