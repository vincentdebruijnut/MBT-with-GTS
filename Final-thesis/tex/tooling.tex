\section{Tooling}\label{sec:tooling}

\subsection{ATM}\label{sec:atm}
ATM is a model-based testing web application, developed in the Ruby on Rails framework. It is used to test the software of several big companies in the Netherlands since 2006. It is under continuous development by Axini.

The UML collaboration diagram of ATM is shown graphically in Figure~\ref{fig:axini_tool}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{atm-diagram.pdf}
  \end{center}
  \caption{ATM collaboration diagram}
  \label{fig:axini_tool}
\end{figure}

The tool functions as follows: 
\begin{enumerate}
  \item An STS is given to an STS Engine, which keeps track of the current location and data values. It passes the possible switch relations from the current location to the Test Manager.
  \item The Test Manager chooses an enabled switch relation based on a test strategy, which can be a random strategy or a strategy designed to obtain a high location/switch relation coverage. The valuation of the variables in the guard are also chosen by a test strategy, which can be a random strategy or a strategy using boundary-value analysis. The choice is represented by an instantiated switch relation and passed back to the STS Engine, which updates its current location and data values. The communication between these two components is done by method calls.
  \item The gate of the instantiated switch relation is given to the Test Execution component as an \textit{abstract stimulus}. The term abstract indicates that the instantiated switch relation is an abstract representation of some computation steps taken in the SUT. For instance, a transition with label '?connect' is an abstract stimulus of the actual setup of a TCP connection between two distributed components of the SUT. 
  \item The translation of an abstract stimulus to a concrete stimulus is done by the Test Execution component. This component provides the stimulus to the SUT. When the SUT responds, the Test Execution component translates this response to an abstract response. For instance, the Test Execution component receives an HTTP response that the TCP connect was succesful. This is a concrete response, which the Test Execution component translates to an abstract response, such as a transition with label '!ok'. The Test Manager is notified with this abstract response.
  \item The Test Manager translates the abstract response to an instantiated switch relation and updates the STS Engine. If this is possible according to the model, the Test Manager gives a pass verdict for this test. Otherwise, the result is a fail verdict.
\end{enumerate}

\subsection{GROOVE}\label{sec:descriptiongroove}
GROOVE is an open source, graph-based modelling tool in development at the University of Twente since 2004~\cite{Rensink:GROOVE}. It has been applied to several case studies, such as model transformations and security and leader election protocols~\cite{Ghamarian:GROOVE}.

The collaboration diagram of GROOVE is shown graphically in Figure~\ref{fig:groove_tool}. A graph grammar is given as input to the RuleApplier component, which determines the possible rule transitions. The user starts an ExplorationStrategy. The possible rule transitions are obtained from the RuleApplier and the chosen rule transition, based on the exploration strategy, is sent back. The ExplorationStrategy can do an exhaustive search, resulting in a GTS. The graph states and rule transitions in this GTS can then be inspected using the UserInterface.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{groove-diagram.pdf}
  \end{center}
  \caption{GROOVE collaboration diagram}
  \label{fig:groove_tool}
\end{figure}

\subsection{Graph grammars in GROOVE}\label{sec:example_groove} 
The running example from Figure~\ref{fig:example_sts} is displayed as a graph grammar, as visualized in GROOVE, in Figure~\ref{fig:example_groove}. The $\mathit{LHS}$, $\mathit{RHS}$ and $\mathit{NAC}$ of a rule in GROOVE are visualized together in one graph. Figures~\ref{fig:example_groove_throw}, \ref{fig:example_groove_move} and \ref{fig:example_groove_next} show three rules. Figure~\ref{fig:example_groove_start} shows the start graph of the system.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The start graph]{\label{fig:example_groove_start}\input{./img/start.tikz}}\quad
    \subfloat[The throw rule]{\label{fig:example_groove_throw}\input{./img/throws.tikz}}
    \subfloat[The move rule]{\label{fig:example_groove_move}\input{./img/move.tikz}}
    \subfloat[The next turn rule]{\label{fig:example_groove_next}\input{./img/nextTurn.tikz}}
  \end{center}
  \caption{The graph grammar of the board game example in Figure~\ref{fig:example_sts}}
  \label{fig:example_groove}
\end{figure}

The colors on the nodes and edges in the rules represent whether they belong to the $\mathit{LHS}$, $\mathit{RHS}$ or $\mathit{NAC}$ of the rule.
\begin{enumerate}
  \item normal line (black): This node or edge is part of both the $\mathit{LHS}$ and $\mathit{RHS}$.
  \item dotted line (red): This node or edge is part of the $\mathit{NAC}$ only.
  \item thick line (green): This node or edge is part of the $\mathit{RHS}$ only.
  \item dashed line (blue): This node or edge is part of the $\mathit{LHS}$ only.
\end{enumerate}

The rules can be described as follows:
\begin{enumerate}
  \item~\ref{fig:example_groove_throw}: 'if a player has the turn and he has not thrown the die yet, he may do so.'
  \item~\ref{fig:example_groove_move}: 'if a player has the turn and he has thrown the die and this number is larger than zero, he may move one place and then it is as if he has thrown one less.'
  \item~\ref{fig:example_groove_next}: 'if a player has finished moving (number thrown is zero), the next player receives the turn.'
\end{enumerate}

The strings on the nodes are a short-hand notation. The bold strings, \textbf{Die}, \textbf{Player}, \textbf{Location} and \textbf{int} indicate the \textit{type} of the node. Nodes with a type starting with a lower case letter, such as \textbf{int}, are variable nodes from $\mathcal{V}$. The italic string \textit{turn}, is a representation of a self-edge with label $turn$. In the next turn rule, the $turn$ edge exists in the $\mathit{LHS}$ as a self-edge of the left \textbf{Player} node and in the $\mathit{RHS}$ as a self-edge of the right \textbf{Player} node. In the same rule, the $throws$ edge from the left \textbf{Player} node to an integer node only exists in the $\mathit{LHS}$.

The 'throws > 0' is a term over the variable node that is the target of an outgoing edge labeled 'throws'. In this case, the valuation of the term be true for the rule to match the graph.

The number '0' in the top left of the \textbf{int} node in the throw rule indicates that this integer is the first parameter in $param(l)$, where $l$ is the label on the rule transition created by applying the throws rule.

The graph is transformed after the rule is applied. The resulting graph after the transformation is the new state of the system and the rule is the transition from the old state (the graph as it was before the rule was applied) to the new state. Figure~\ref{fig:gts_example} shows the IOGTS of one \textit{?throws} rule application on the start graph. Note that the \textit{?throws} is an input, as indicated by the '?'. State $s_1$ is a representation of the graph in Figure~\ref{fig:example_groove_start}. Figure~\ref{fig:target_graph_state} shows the graph represented by $s_2$.

\begin{figure}[ht]
  \begin{center}
    \input{./img/gts-transition-example.tikz}
  \end{center}
  \caption{The GTS after one rule application on the board game example in Figure~\ref{fig:example_groove}}
  \label{fig:gts_example}
\end{figure}

\begin{figure}[ht]
  \begin{center}
    \input{./img/target-graph-state.tikz}
  \end{center}
  \caption{The graph of state $s2$ in Figure~\ref{fig:gts_example}}
  \label{fig:target_graph_state}
\end{figure}
