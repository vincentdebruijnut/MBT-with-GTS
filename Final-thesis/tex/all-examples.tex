\section{Models}
This section shows the IOGG and IOSTS for each model example and the case study. 

\subsection{Example 1: boardgame}
The boardgame is the running example of which the IOSTS and IOGG are given in Figures~\ref{fig:example_sts} and \ref{fig:example_groove} respectively. In order to be consistent with the GG variable definition, the two $Player$ and $Die$ nodes receive the flags $\mathit{var1, var2, var3}$ respectively, representing the variable labels.

\subsection{Example 2: farmer-wolf-goat-cabbage}
In this puzzle, a farmer, wolf, goat and cabbage are on one side of a river. The farmer can take upto one item to the other side. If the wolf and goat are on one side of the river without the farmer, the wolf eats the goat and the puzzle is reset. This also holds for the goat and the cabbage. The goal is to move all four to the other side of the river. The stimuli accepted by the puzzle are:
\begin{itemize}
\item $?n$ Move the farmer to the other river bank
\item $?w$ Move the wolf to the other river bank
\item $?g$ Move the goat to the other river bank
\item $?c$ Move the cabbage to the other river bank
\end{itemize}
The responses given by the puzzle are:
\begin{itemize}
\item $!retry$ When $?w, ?g$ or $?c$ is given but the farmer is not on the same river bank as the item
\item $!eaten$ An item eats another item on one river bank, with the farmer on the other river bank 
\item $!done$ When all four items are on the other river bank
\end{itemize}

The IOGG of this puzzle is in Appendix~\ref{app:fwgc}. The response rules `!retry', `!eaten' and `!done' have a higher priority. This ensures that a proper response is given after a move, before allowing more stimuli.

\begin{comment}
\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:start-bg}\input{./img/start-fwgc.tikz}}\hspace{20px}
    \subfloat[The ?c (move cabbage) rule with priority 0]{\label{fig:c-fwgc}\input{./img/c-fwgc.tikz}}\\
    \subfloat[The ?c (invalid cabbage move) rule with priority 0]{\label{fig:c-invalid-fwgc}\input{./img/c-invalid-fwgc.tikz}}\hspace{20px}
    \subfloat[The !retry rule with priority 1]{\label{fig:retry-fwgc}\input{./img/retry-fwgc.tikz}}\\
    \subfloat[The !eaten rule with priority 1]{\label{fig:reinit}\input{./img/eaten-reinit-fwgc.tikz}}\\
    \subfloat[The !done rule with priority 1]{\label{fig:done}\input{./img/done-fwgc.tikz}}
  \end{center}
  \caption{The IOGG of the farmer-wolf-goat-cabbage puzzle}
  \label{fig:gg-fwgc}
\end{figure}
\end{comment}

The IOSTS of this puzzle is is given in the formal definition, because it is too large for the visual representation. It uses boolean location variables to indicate whether the item is on the other side. These are checked to see if an invalid move is done, an item is being eaten or the puzzle has been completed.
\vspace{5px} \\
$\begin{array}{lcl}
\Locations & = & \{l_0, l_1\} \\
\initialLocation & = & l_0 \\
\LocationVariables & = & \{N,W,G,C\} \\
\initializationFunction & = & \{N \mapsto false, W \mapsto false, G \mapsto false, C \mapsto false\} \\
\InteractionVariables & = & \{\} \\
\Gates & = & \{?n, ?w, ?g, ?c, !eaten, !done, !retry\} \\
\Switches & = & \{l_0\xrightarrow{?n, \neg(N \neq G \land G=C)\lor(N \neq W \land W=G), \{N \mapsto \neg N\}}l_0, \\
& & l_0\xrightarrow{?w, N=W \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{W \mapsto \neg W, N \mapsto \neg N\}}l_0,\\
& & l_0\xrightarrow{?g, N=G \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{G \mapsto \neg G, N \mapsto \neg N\}}l_0,\\
& & l_0\xrightarrow{?c, N=C \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{C \mapsto \neg C, N \mapsto \neg N\}}l_0,\\
& & l_0\xrightarrow{?w, N\neq W \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{W \mapsto \neg W, N \mapsto \neg N\}}l_1,\\
& & l_0\xrightarrow{?g, N\neq G \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{G \mapsto \neg G, N \mapsto \neg N\}}l_1,\\
& & l_0\xrightarrow{?c, N\neq C \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{C \mapsto \neg C, N \mapsto \neg N\}}l_1,\\
& & l_1\xrightarrow{!retry,true,\{\}}l_0,\\
& & l_0\xrightarrow{!eaten, (N \neq G \land G=C)\lor(N \neq W \land W=G), \{N \mapsto false, W \mapsto false, G \mapsto false, C \mapsto false\}}l_0, \\
& & l_0\xrightarrow{!done, N \land W \land G \land C, \{N \mapsto false, W \mapsto false, G \mapsto false, C \mapsto false\}}l_0\}
\end{array}$

%\begin{figure}[ht]
%  \begin{center}
%    \input{./img/sts_fwgc.tex}
%  \end{center}
%  \caption{The IOSTS of the farmer-wolf-goat-cabbage puzzle}
%  \label{fig:sts-fwgc}
%\end{figure}

\subsection{Example 3: bar tab system}
This example models a bar tab system, where customers can order beer, wine and soda. The price of the order adds to tab. Customers can pay their tab with money; they receive cash back if the payment exceeds the tab. The model is abstracted to include three customers. Furthermore, a customer can order only one drink. Drinks and payments are processed immediately before other drinks or payments can occur. The stimuli accepted by the system are:
\begin{itemize}
\item $?o(i,d)$ for ordering a drink $d$ on bar tab $i$
\item $?p(i,p)$ for paying amount $p$ on bar tab $i$
\end{itemize}
The responses given by the system are:
\begin{itemize}
\item $!po(b)$ for processing an order giving the new bar tab balance $b$
\item $!pp(b,r)$ for processing a payment giving the new account balance $b$ and the return funds $r$
\end{itemize}

Figure~\ref{fig:gg-bartab} shows the IOGG of the bar tab system. The `!po' and `!pp` rules have a higher priority than the `?o' and `?p' rules.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:start-tab}\input{./img/start-tab.tikz}}\\
    \subfloat[The ?o rule with priority 0]{\label{fig:order-tab}\input{./img/order-tab.tikz}}\hspace{20px}
    \subfloat[The !po rule with priority 1]{\label{fig:process_order}\input{./img/process_order.tikz}}\\
    \subfloat[The ?p rule with priority 0]{\label{fig:pay-tab}\input{./img/pay-tab.tikz}}\hspace{20px}
    \subfloat[The !pp rule with priority 1]{\label{fig:process_payment}\input{./img/process_payment.tikz}}
  \end{center}
  \caption{The graph grammar of the bar tab system}
  \label{fig:gg-bartab}
\end{figure}

Figure~\ref{fig:sts-bartab} shows the IOSTS of the bar tab system. The IOSTS uses the variables $T_1, T_2, T_3$ to keep track of the bar tabs of the three people. It uses the variables $I, P$ as temporary variables for the id and payment/price respectively. The function $m$ takes the maximum value of its parameters.

\begin{figure}[ht]
  \begin{center}
    \input{./img/sts_tab.tex}
  \end{center}
  \caption{The IOSTS of the bar tab system}
  \label{fig:sts-bartab}
\end{figure}

\subsection{Failed example: restaurant reservations}
In this example, a restaurant with three tables allow customers to reserve tables for a certain time slot.

Figure~\ref{fig:reservation_start} shows the initial graph of three tables at a restaurant and two potential customers. Figure~\ref{fig:make-reservation} shows part of a rule that allows people to make reservations. The start and end times are timestamps represented by integers. This rule allows people to make multiple reservations. However, this rule violates the unique GG variables constraint in section~\ref{sec:constraints}, because the reservation objects are not unique. Allowing a dynamic amount of reservations per person means that variables need to be introduced dynamically as well or more complex variables have to be used, such as arrays. To model this system using an IOSTS, arrays are also needed.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:reservation_start}\input{./img/start-reservation.tikz}}\hspace{20px}
    \subfloat[The make reservation rule]{\label{fig:make-reservation}\input{./img/makeReservation.tikz}}
  \end{center}
  \caption{The IOGG of the restaurant reservation system}
  \label{fig:gg-reservation}
\end{figure}

\subsection{Case study: Scanflow Cash Register Protocol}
The system used for this case study is a \textit{self-scan register}, which allows customers of a supermarket to scan and pay for their products without help of an employee. Figure~\ref{fig:register} shows this self-scan register. The system contains a \textit{scanflow unit}, which scans the products, and a \textit{cash register}, which handles the payment. The communication protocol between the register and the scanflow unit is the system which is tested. The register is the SUT, stimuli and responses are given as http requests/responses. Appendix~\ref{app:scrp-specification} lists a detailed overview of the specification for this communication protocol.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.3\textwidth]{scanflow.jpg}
  \end{center}
  \caption{A self-scan register}
  \label{fig:register}
\end{figure}

Some selected rules of the IOGG of this communication protocol are shown in Figure~\ref{fig:gg-scrp}. In total the IOGG has 94 rules. They are all listed in Appendix~\ref{app:scrp-gg}. Figure~\ref{fig:start-scrp} shows the initial graph. The $CR$ node is the cash register, the $SFU$ is the scanflow unit. The first node has the flag $\mathit{SS\_OFF}$ representing that the register is off. There is one account which can be in states idle, open, closed and transing. When the customer places items on the belt, a new account is opened. Figure~\ref{fig:open-account-request} shows the general request structure. As long as there is no request, a request can be sent. This rule requests the opening of an account. Figure~\ref{fig:open-account-success} shows the rule for giving a success response. The request node is deleted such that new request nodes can be created again. The rule checks if an account is not already opened and opens an idle account. Figure~\ref{fig:open-account-invalid} shows the rule for the error message received when an account is already opened. 

\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:start-scrp}\input{./img/start-scrp.tikz}}\hspace{20px}
    \subfloat[The open account request rule]{\label{fig:open-account-request}\input{./img/account.open.request.tikz}}\\
    \subfloat[The open account success rule]{\label{fig:open-account-success}\input{./img/account.open.success.tikz}}\hspace{20px}
    \subfloat[The open account invalid rule]{\label{fig:open-account-invalid}\input{./img/account.open.invalid_ss_on.tikz}}\\
    \subfloat[The not signed on error rule]{\label{fig:not-signed-on}\input{./img/general_responses.not_signed_on.tikz}}\hspace{20px}
    \subfloat[The close account success rule]{\label{fig:close-account-success}\input{./img/account.close.success.tikz}}
  \end{center}
  \caption{The IOGG of the Scanflow Cash Register Protocol}
  \label{fig:gg-scrp}
\end{figure}

For all these rules, the $CR$ node has to have the flag $\mathit{SS\_ON}$ representing the register to be signed on. Figure~\ref{fig:not-signed-on} shows the response to a request when the register is not signed on. Apart from the signon request, no other request is allowed in this state. Figure~\ref{fig:close-account-success} shows the rule closing the account.

The IOSTS of the system as created by Axini is too large to show here. It has X switch relations and Y location variables.