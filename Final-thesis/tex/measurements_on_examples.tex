\section{Measurements on examples}

\subsection{Simulation and redundancy}\marginpar{Need to verify this using LTS min}

\paragraph*{Boardgame}
The responses used by the IOSTS and by the IOGG are different. Both models, used as examples to clarify the IOSTS and IOGG formalisms, were built with a different behavior in mind. Both allow a die to be thrown, after which the IOSTS directly moves the player to the correct location and passes the turn and the IOGG moves the player by a series of responses ended with a $!nextTurn$. Therefore, both IOSTSs do not simulate each other.

\paragraph*{Farmer-wolf-goat-cabbage puzzle}
Table~\ref{tab:fwgc-simulate} shows the results for this measurement for the puzzle. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Model} & \textbf{Simulates?} & \textbf{Switch relations} & \textbf{Location variables} & \textbf{Redundant?} \\ \hline
Generated IOSTS & true & 50 & 0 & false \\ \hline
Modelled IOSTS & true & 11 & 4 & false \\ \hline
\end{tabular}
\end{center}
\caption{Simulation and redundancy results for the farmer-wolf-goat-cabbage puzzle}
\label{tab:fwgc-simulate}
\end{table}

The IOGG does not use variables to track the location of each item. Therefore, the generated IOSTS has a location per state of the puzzle. Since on neither side both the number of switch relations and location variables are higher, both models are not redundant.

\paragraph*{Bar-tab system}
Table~\ref{tab:bar-tab-simulate} shows the results for this measurement for the bar-tab system. 

\begin{table}[ht]
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Model} & \textbf{Simulates?} & \textbf{Switch relations} & \textbf{Location variables} & \textbf{Redundant?} \\ \hline
Generated IOSTS & true & 24 & 13 & true \\ \hline
Modelled IOSTS & true & 10 & 5 & false \\ \hline
\end{tabular}
\caption{Simulation and redundancy results for the bar-tab system}
\label{tab:bar-tab-simulate}
\end{table}

The modelled IOSTS keeps the name and price of drinks as location variables, whereas the generated IOSTS hard-codes these into the guards and updates. The generated IOSTS builds a switch relation with gate $?o$ for each combination of customer and drink. It also builds a switch relation with gate $?p$ for each customer. The target locations of all these switch relations have one switch relation back to the initial location. Therefore, the number of switch relations is $3*3*2+3*1*2\: =\: 24$. This could have been avoided by modelling GG variables for the price and drinks. However, this would make the IOGG more complex. 

\paragraph*{SCRP}
Table~\ref{tab:scrp-simulate} shows the results for this measurement for the case study.

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Model} & \textbf{Simulates?} & \textbf{Switch relations} & \textbf{Location variables} & \textbf{Redundant?} \\ \hline
Generated IOSTS & ? & 540 & 2 & ? \\ \hline
Modelled IOSTS & ? & 1302 & 2 & ? \\ \hline
\end{tabular}
\end{center}
\caption{Simulation and redundancy results for the SCRP}
\label{tab:scrp-simulate}
\end{table}

%The generated IOSTS allows every stimulus in every location. The IOSTS by hand is modelled to test a subset of the more interesting behavior.

\subsection{Performance}
The performance of GRATiS on all models is in Table~\ref{tab:performance}.

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Example} & \textbf{runtime (ms)} & \textbf{heap-size (MB)} \\ \hline
boardgame & 300 & 1.9 \\ \hline
farmer-wolf-goat-cabbage puzzle & 770 & 5.2 \\ \hline
bar-tab system & 250 & 2.1 \\ \hline
SCRP & 9530 & 6.6 \\ \hline
\end{tabular}
\end{center}
\caption{Performance measurements}
\label{tab:performance}
\end{table}

Comparing to the examples the case-study shows little increase in heap-size and approximately 20 times higher runtime. The algorithm scales reasonably well, considering the generated IOSTS is approximately 10 times larger in size than those of the examples.

\subsection{Model complexity}
Table~\ref{tab:halstead} shows the measurements on the operators and operands of all models.

\begin{table}[ht]
\begin{center}
\begin{tabular}{| l | l | c | c | c | c | c |}
  \hline
  \textbf{Example} & \textbf{Model} & $n_1$ & $n_2$ & $N_1$ & $N_2$ & Volume \\ \hline
  boardgame & IOGG & 9 & 18 & 24 & 103 & 603.25 \\
  & IOSTS & 5 & 22 & 25 & 62 & 413.25 \\ \hline
  farmer-wolf-goat-cabbage puzzle & IOGG & 3 & 13 & 25 & 125 & 498.29 \\ 
  & IOSTS & 9 & 22 & 25 & 62 & 431.02 \\ \hline
  bar-tab system & IOGG & 3 & 13 & 25 & 125 & 498.29 \\
  & IOSTS & 9 & 22 & 25 & 62 & 431.02 \\ \hline
  SCRP & IOGG & 9 & 18 & 24 & 103 & 603.25 \\ 
  & IOSTS & 5 & 22 & 25 & 62 & 413.25 \\
  \hline
\end{tabular}
\end{center}
\caption{The Halstead measurements on the boardgame models}
\label{tab:halstead}
\end{table}\marginpar{Deze metingen moeten nog gechecked worden}

\subsection{Extendability}
The next paragraphs contain a hypothetical extension to each example. New models are given which feature the extension. In the last paragraph, the increase in model complexity for each example is given in a table.

\paragraph*{Boardgame}
The boardgame is extended to include one more player and one more location. For the IOGG, this means adding new locations and players to the initial graph. The players get a fixed order in which they play. This means that the next turn rule also has to be extended. The rest of the rules stay as they are. The extended rules are in Figure~\ref{fig:gg-bg-extended}.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:start-bg-extended}\input{./img/start-bg-extended.tikz}}\hspace{20px}
    \subfloat[The next turn rule]{\label{fig:nextTurn-bg-extended}\input{./img/nextTurn-bg-extended.tikz}}
  \end{center}
  \caption{The extended graph grammar of the board game example in Figure~\ref{fig:example_groove}}
  \label{fig:gg-bg-extended}
\end{figure}

The IOSTS gains a variable and a switch relation for the new player:
\vspace{5px} \\
$\begin{array}{lcl}
\Locations & = & \{t, m\} \\
\initialLocation & = & t \\
\LocationVariables & = & \{T, P1, P2, P3, D\} \\
\initializationFunction & = & \{T \mapsto 0, P1 \mapsto 0, P2 \mapsto 2, P3 \mapsto 0, D \mapsto 0\} \\
\InteractionVariables & = & \{d, p, l\} \\
\Gates & = & \{?throw, !move\} \\
\Switches & = & \{t\xrightarrow{?throw, 1 <= d <= 6, D \mapsto d}m, \\
 & & m\xrightarrow{!move, T=1 \land l=(P1+D)\%5, P1 \mapsto l, T \mapsto 2}t, \\
 & & m\xrightarrow{!move, T=2 \land l=(P2+D)\%5, P2 \mapsto l, T \mapsto 3}t, \\
 & & m\xrightarrow{!move, T=3 \land l=(P3+D)\%5, P3 \mapsto l, T \mapsto 1}t\}
\end{array}$

\paragraph*{Farmer-wolf-goat-cabbage puzzle}
In another variant of this puzzle, when one of the items is eaten, the puzzle can reset, but it can also undo the last action. The $\mathit{!eaten}$ rule can have either effect. In Figure~\ref{fig:gg-fwgc-extended} shows this extension for the IOGG in five rules. The rules keep track of the last moved items. When an item gets eaten, the last move can be undone.

\begin{figure}[ht]
  \begin{center}
    \subfloat[!eaten (undo)]{\label{fig:eaten-undo-fwgc}\input{./img/fwgc/eaten-undo-fwgc.tikz}} \hspace{20px}
    \subfloat[?c]{\label{fig:c-fwgc-extended}\input{./img/fwgc/c-fwgc-extended.tikz}} \\
    \subfloat[?g]{\label{fig:g-fwgc-extended}\input{./img/fwgc/g-fwgc-extended.tikz}} \hspace{20px}
    \subfloat[?w]{\label{fig:w-fwgc-extended}\input{./img/fwgc/w-fwgc-extended.tikz}} \\
    \subfloat[?n]{\label{fig:n-fwgc-extended}\input{./img/fwgc/n-fwgc-extended.tikz}}
  \end{center}
  \caption{The extended graph grammar of the farmer-wolf-goat-cabbage puzzle}
  \label{fig:gg-fwgc-extended}
\end{figure}

The IOSTS keeps extra variables for the previous positions of the items and adds one switch relation that restores the items to their previous positions when an item gets eaten.
\vspace{5px} \\
$\begin{array}{lcl}
\Locations & = & \{l_0, l_1\} \\
\initialLocation & = & l_0 \\
\LocationVariables & = & \{N,W,G,C,Np, Wp, Gp, Cp\} \\
\initializationFunction & = & \{N \mapsto false, W \mapsto false, G \mapsto false, C \mapsto false,Np \mapsto false, Wp \mapsto false, Gp \mapsto false, Cp \mapsto false\} \\
\InteractionVariables & = & \{\} \\
\Gates & = & \{?n, ?w, ?g, ?c, !eaten, !done, !retry\} \\
\Switches & = & \{l_0\xrightarrow{?n, \neg(N \neq G \land G=C)\lor(N \neq W \land W=G), \{N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_0, \\
& & l_0\xrightarrow{?w, N=W \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{W \mapsto \neg W, N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_0,\\
& & l_0\xrightarrow{?g, N=G \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{G \mapsto \neg G, N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_0,\\
& & l_0\xrightarrow{?c, N=C \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{C \mapsto \neg C, N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_0,\\
& & l_0\xrightarrow{?w, N\neq W \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{W \mapsto \neg W, N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_1,\\
& & l_0\xrightarrow{?g, N\neq G \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{G \mapsto \neg G, N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_1,\\
& & l_0\xrightarrow{?c, N\neq C \land (N = G \lor G\neq C)\land (N = W \lor W\neq G), \{C \mapsto \neg C, N \mapsto \neg N, Np \mapsto N, Wp \mapsto W, Gp \mapsto G, Cp \mapsto C\}}l_1,\\
& & l_1\xrightarrow{!retry,true,\{\}}l_0,\\
& & l_0\xrightarrow{!eaten, (N \neq G \land G=C)\lor(N \neq W \land W=G), \{N \mapsto false, W \mapsto false, G \mapsto false, C \mapsto false\}}l_0, \\
& & l_0\xrightarrow{!eaten, (N \neq G \land G=C)\lor(N \neq W \land W=G), \{N \mapsto Np, W \mapsto Wp, G \mapsto Gp, C \mapsto Cp\}}l_0, \\
& & l_0\xrightarrow{!done, N \land W \land G \land C, \{N \mapsto false, W \mapsto false, G \mapsto false, C \mapsto false\}}l_0\}
\end{array}$

\paragraph*{Bar-tab system}
The system is extended to allow ordering multiple drinks of different types. Also, a customer can purchase the option of receiving 10\% discount on all ordered drinks for 50 euros, which is added to the tab of the customer.
\vspace{5px}
\begin{itemize}
\item $?o(i,d_1,q_1,d_2,q_2,d_3,q_3)$ is used to order a quantity $q_n$ of drink $d_n$ on bar tab $i$. 
\item $?\mathit{d}$ is used to order the discount.
\item $!pd(b)$ process the discount where $b$ is the new balance. 
\end{itemize}
\vspace{5px}
Figure~\ref{fig:gg-bartab-extended} shows the extended rules and initial graph. The $?p$ and $!pp$ rules have remained the same.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:start-tab-extended}\input{./img/start-tab-extended.tikz}}\hspace{20px}
    \subfloat[!pd (priority 1)]{\label{fig:process_discount}\input{./img/process_discount-extended.tikz}}\\
    \subfloat[?o (priority 1)]{\label{fig:order-tab-extended}\input{./img/order-extended.tikz}}\hspace{20px}
    \subfloat[?d (priority 0)]{\label{fig:discount}\input{./img/discount-extended.tikz}}\\
    \subfloat[!po (priority 1)]{\label{fig:process_order-extended}\input{./img/process_order-extended.tikz}}\\
  \end{center}
  \caption{The extended IOGG of the bar tab system}
  \label{fig:gg-bartab-extended}
\end{figure}

\begin{figure}[ht]
  \begin{center}
    \input{./img/sts_tab-extended.tex}
  \end{center}
  \caption{The extended IOSTS of the bar tab system}
  \label{fig:sts-bartab-extended}
\end{figure}

\paragraph*{SCRP}
A recent extension on the protocol allows multiple accounts. While an account is not in state open, an idle account can be opened. This allows for a customer to scan his/her products, while another customer pays. Figure~\ref{fig:gg-fwgc-extended} shows the changes to the initial graph and the open account rules. Figure~\ref{fig:close-account-success-ext} shows the success response rule for closing an account: the order of closed accounts have to be kept, because the accounts have to be paid in that order.

\begin{figure}[ht]
  \begin{center}
    \subfloat[The initial graph]{\label{fig:start-scrp-ext}\input{./img/start-scrp-extended.tikz}}\hspace{20px}
    \subfloat[The open account success rule]{\label{fig:open-account-success-ext}\input{./img/scrp/account.open.success-extended.tikz}}\\
    \subfloat[The open account invalid rule]{\label{fig:open-account-invalid-ext}\input{./img/scrp/account.open.invalid_ss_on-extended.tikz}}\hspace{20px}
    \subfloat[The close account success rule]{\label{fig:close-account-success-ext}\input{./img/scrp/account.close.success-extended.tikz}}
  \end{center}
  \caption{The extended graph grammar of Scanflow Cash Register Protocol}
  \label{fig:gg-fwgc-extended}
\end{figure}

\paragraph*{Model complexity increase}
\begin{comment}
1:
IOGG:
This extension reduces the distinct number of operators by 1 and introduces no new operands. The number of operator occurences has decreased by 1 and the number of operand occurences has grown by 10.
IOSTS:
The distinct number of operators has not increased and the distinct number of operands has increased by 1. The number of operator occurences has increased by 9 and the number of operand occurences has increased by 17.

model complexity 1
The volume of the IOGG has increased by 35.95. $n_1 = 8, n_2 = 18, N_1 = 23, N_2 = 113$ Volume is 136*4.70 = 639.20
The volume of the IOSTS has increased by 130.28. $n_1 = 5, n_2 = 23, N_1 = 34, N_2 = 79$ Volume is 113*4.81 = 543.53

2:
IOGG:
\end{comment}

\section{Conclusions}
\begin{comment}
\marginpar{conclusions per measurement, conclusions per case? General conclusions later}
The simulation measurement in the boardgame example shows that not having a fixed specification leads to different behavior specified by the generated IOSTS. The translation of abstract stimuli and responses to the concrete stimuli and responses gives flexibility; an expected series of responses $!move(1) !move(1) !nextTurn$ can be translated from the concrete response $!move(1,2)$. However, this does give more work in the abstract to concrete stimuli/response translation. Also, the model does not reflect the specification precisely when using such a work-around.

The redundancy measurement reveals an interesting result in the bar tab example. Here, the possible morphisms of the rules on the graph lead to more switch relations than when the IOSTS is created by hand. This effect is common: in a GG, it is easy to represent the actors and rules specifying the interaction between these actors. The result is a switch relation for each combination of customer and drink. This is not a problem as long as the size of the generated IOSTS is manageable by GRATiS. If the number of switch relations becomes too great, creating the smaller IOSTS by hand also becomes unmanageable.

%The redundancy measurement also shows that for the farmer-wolf-goat-cabbage puzzle, the IOGG is easier expressed using no variables. 

It can be conlcuded that for these small examples the runtime and heap-size of the IOSTS generation are negligible. The results on the case study will show how this measurement scales using larger models.

Halstead conlcusions here.

Extendability conclusions here.

The lack of complex data structures, such as arrays, sets and objects is apparent from the restaurant reservation example. GGs inherently are Object-Oriented, which can be best seen in the bar tab example, where ids and tabs are combined, as well as names and prices. The lack of a summation operation in GROOVE causes the large GG of the extended bar tab system. Figure~\ref{fig:gg-tab-better} shows how this rule could look like. 

\begin{figure}[ht]
  \begin{center}
    \input{./img/process_order-better.tikz}
  \end{center}
  \caption{A rule of the bar tab system containing the sum operation}
  \label{fig:gg-tab-better}
\end{figure}

\subsection{SCRP conclusions}
The case study showed a real life example of a software system, succefully modelled as a GG. Here, the strength of behavioral rules is apparent: instead of state-transition thinking, the graph transformation rules allow each behavioral aspect of a software system to be modelled by one rule. This is most visible in the 'not signed on' error rule. This rule models the aspect of giving an error when a request is done in the signed off state, regardless of any other state the system is in. Restrictions of where this rule applies can be easily added, as shown with the exception made for the 'sign on' request. This shows that GGs are very useful when it comes to changing requirements: only few rules need to be adjusted to accomodate these changes. Another example is the request structure of the GG. The stimulus and expected response are automatically included for every system state. This again shows the strength of GGs; behavior is modelled once and tested in every system state. 
\end{comment}
