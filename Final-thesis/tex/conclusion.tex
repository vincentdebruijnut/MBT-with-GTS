\section{Research goals}
This report shows the usability of Graph Grammars in model-based testing. The motivation to use GGs is supported by literature, emphasizing the understandibility of graphs and the usefulness of graphs to express system states. Symbolic Transition Systems are a useful formalism which are easily used by computers. This supports using a GG for testers to model a software system and generating the IOSTS from the IOGG for the computer to use during testing. 
The point algebra was shown to be useful for achieving the generation of an IOSTS. The design requirements for GRATiS are all met, because:
\begin{itemize} 
\item the technique proved effective for model-based testing in several example cases and a larger case study
\item coverage can be measured on the generated IOSTS
\item the performance measurements show that the IOSTS can be generated from large models in a negligible time and that the technique scales well
\end{itemize}

\section{Contributions}
Generating the location variables in an STS meant creating an extra definition for GGs, which allowed persistent variables. The definition lets edges to data values to be considered as variables; this was a choice needed to generate the IOSTS. GGs can dynamically add these variables or delete them; something which was frequently desired to obtain the smallest and most intuitive models, but which complicates the generation of the IOSTS. Hence, constraints on GG transformation rules were defined mostly to accomdate the GG variable definition.

One of the example cases, the reservation system, suffered from the constraints the most. This example could not be modelled, because dynamically deleting and creating GG variables was required. The puzzle example on the other hand shows the strength of GGs the most, through simple, intuitive rules opposed to a complicated transition system. This shows that some systems are more suitable to be modelled in GGs than others.

The case study done in this report on the self-scan register shows a real life example of a software system, succefully modelled as an IOGG. Here, the strength of behavioral rules is apparent: instead of state-transition thinking, the graph transformation rules allow each behavioral aspect of a software system to be modelled by one rule. For example, the `not signed on' error, given when the register is in the `not signed on' state. This error can be given in numerous states in the IOSTS, but simply described in the IOGG by matching the state of the register. Additional restrictions of where this rule applies can be easily added to the rule. In state-transition based models, high many states and transitions are often needed to model the same behavior described by one GG rule. This shows that IOGGs are very useful when it comes to changing requirements: only few rules need to be adjusted to accomodate these changes.

Model complexity measurements were done on the IOGGs and IOSTSs of the example cases and case study. This did not reveal a clear difference in overall model complexity. However, it did show that IOGGs generally have more distinct operands, but less overall operators. The first part is due to the labels on nodes and edges, which describe the nature of the nodes and the relation between the nodes; these operands are not present in the IOSTSs. The second part can be explained by the repetition needed in IOSTSs to describe the same behavior as one IOGG rule.
