In this introduction, first the importance of testing and automation of testing is stressed. Then Model-Based Testing is shown to be a useful tool for automation of testing. Graph Grammars and graph transformation are argued to be useful as formalism for Model-Based Testing. Some leading tools for automatic test generation are set out, which include the tools used in this report. The research goals are given and finally a roadmap explains the basic structure of the rest of this report.

\section{Testing}
In software development projects, often time and budget costs are exceeded. Laird and Brennan~\cite{Laird:SoftwareMeasurement} investigated in 2006 that 23\% of all software projects are canceled before completion. Furthermore, of the completed projects, only 28\% are delivered on time with the average project overrunning the budget with 45\%. The cause of this often are the unclear ambigious requirements of the software system to develop.

Testing is an important part of software development, because it decreases future maintainance costs~\cite{McConnell:testing}. Testing is a complex process and should be done often~\cite{Pol:testing}. Therefore, the testing process should be as efficient as possible in order to save resources.

Test automation allows repeated testing during the development process. The advantage of this is that bugs are found early and can therefore be fixed early.  A widely used practice is maintaining a \textit{test suite}, which is a collection of test-cases. However, when the creation of a test suite is done manually, this still leaves room for human error~\cite{Blackburn:testing}. The process of deriving tests tends to be unstructured, barely motivated in the details, not reproducible, not documented, and bound to the ingenuity of single engineers~\cite{Utting:MBTTaxonomy}.

\section{Model-based Testing}
The existence of an artifact that explicitly encodes the intended behaviour can help mitigate the implications of these problems. Creating an abstract representation or a \textit{model} of the system is an example of such an artifact. What is meant by a model in this report, is the description of the behavior of a system. In particular, the term model will be often used to describe transition-based notations, such as finite state machines, labelled transition systems and I/O automata. Other notations, such as UML statecharts, are not considered as models in this report. 

A model can be used to systematically generate tests for the system. This is referred to as \textit{Model-Based Testing}. Generating tests automatically leads to a larger test suite than if done manually. A large, systematically built test suite is bound to find more bugs than a smaller, manually built one.

Models are created from the specification documents provided by the end-user. These specification documents are `notoriously error-prone'~\cite{McCabe:testing}. This implies that the model itself needs validation. Validating the model usually means that the requirements themselves are scrutinised for consistency and completeness~\cite{Utting:MBTTaxonomy}. This helps to clear up ambigious requirements early on, which allows better estimation of the budget and time demands.

The stakeholders evaluate the constructed model to verify its correctness. However, the visual or textual representation of large models may become troublesome to understand, which is referred to as the model having a low model transparency or high model complexity. The problem with transition systems is that a larger number of states and/or transitions decreases the model transparency. We think that low model transparency make errors harder to detect and that it obstructs the feedback process of the stakeholders. Using models with high transparency is therefore essential.

\section{Graph Transformation}\label{sec:gg_intro}
A formalism that claims to have higher model transparency is Graph Transformation. The system states are represented by graphs and the transitions between the states are accomplished by applying graph change rules to those graphs. These rules can be expressed as graphs themselves. A graph transformation model of a software system is therefore a collection of graphs, each a visual representation of one aspect of the system. This formalism may therefore provide a more intuitive approach to system modelling than traditional state machines. Graph Transformation and its potential benefits have been studied since the early '70s~\cite{Pratt1971}. The usage of this computational paradigm is best described by the following quote from Andries et al.~\cite{Andries1999}: \begin{quote}Graphs are well-known, well-understood, and frequently used means to represent system states, complex objects, diagrams, and networks, like flowcharts, entity-relationship diagrams, Petri nets, and many more. Rules have proved to be extremely useful for describing computations by local transformations: Arithmetic, syntactic, and deduction rules are well-known examples.\end{quote} An informative paper on graph transformations is written by Heckel et al.~\cite{Heckel2006187}. A quote from this paper: \begin{quote}Graphs and diagrams provide a simple and powerful approach to a variety of problems that are typical to computer science in general, and software engineering in particular.\end{quote}

\section{Tools}
Tools for model-based testing and tools for graph transformation already exist. The leading tools in these areas are investigated in this section.

The testing tool developed by Axini\footnote{http://www.axini.nl/} is used for the automatic test generation on \textit{symbolic} models, which combine a state and data type oriented approach. This tool is referred to as Axini Test Manager (ATM) and is used in practice by several Dutch companies.

In Utting et al.~\cite{Utting:MBTTaxonomy}, a taxonomy is done on different Model-Based Testing tools:
\begin{itemize}
  \item TorX~\cite{Tretmans:TorX}: accepts behaviour models such as I/O labelled transition systems. A version of this tool written in Java under continuous development is JTorX~\cite{Belinfante:JTorX}. This version accepts the same kind of models as ATM.
  \item Spec Explorer\cite{Veanes:SpecExplorer}: provides a model editing, composition, exploration and visualization environment within Visual Studio, and can generate offline .NET test suites or execute tests as they are generated (online).
  \item JUMBL\cite{Prowell:JUMBL}: an academic model-based statistical testing that supports the development of statistical usage-based models using Markov chains, the analysis of models, and the generation of test cases.
  \item AETG\cite{Cohen:AETG}: implements combinatorial testing, where the number of possible combinations of input variables are reduced to a few `representative' ones.
  \item STG tool\cite{clarke:STG}: implements conformance testing techniques to automatically derive symbolic test cases from formal operational specifications.
\end{itemize}

Table~\ref{tab:gg_tools} shows the graph transformation tools that participated at the Transformation Tool Contest 2011 in Zurich\cite{DBLP:gg_tools}, with a comparison based on their strong points.

\begin{table}[ht]
\begin{center}
\begin{tabular}{l}
\hline
\textbf{Suitability and strong points of the tool} \\ \hline

\textbf{ATL/EMFTVM}: \textit{general-purpose model transformation.} \\
ATL is a mature language for mapping input models to output models. \\
The EMFTVM runtime introduces composition and rewriting.  \\ \hline

\textbf{Edapt}: \textit{model migration in response to metamodel adaptation.} \\
High automation by reuse of recurring migration specifications. \\
In-place transformation, seamless metamodel editor integration.  \\ \hline

\textbf{GrGen.NET}: \textit{general-purpose graph rewriting.} \\
Pattern matching of high performance and expressiveness; highly programmable. \\
Excellent debugging and documentation. Focus on compilers, computer linguistics. \\ \hline

\textbf{GROOVE}: \textit{state space exploration, general-purpose graph rewriting.} \\
Rapid prototyping, visual debugging, model checking. \\
Expressive language (nested rules, transactions, control); isomorphism reduction.  \\ \hline

\textbf{Henshin}: \textit{graph transformations for EMF models with explicit control flow.} \\
Expressive language (nested rules, support for higher-order transformations) \\
JavaScript support, light-weight model \& API, state space analysis  \\ \hline

\textbf{MDELab SDI}: \textit{graph transformations for EMF models with explicit control flow.} \\
Expressive language, mature graphical editor, support for debugging at model level. \\
High flexibility, easy integration with other EMF/Java applications.  \\ \hline

\textbf{metatools}: \textit{general-purpose model transformations.} \\
Seamless integration of hand-written and generated sources, of imperative \\
and declarative style. Full access to host language, libraries and legacy code.  \\ \hline

\textbf{MOLA}: \textit{general-purpose model transformations with explicit control flow.}\\
Expressive language, graphical editor with graphical code completion and refactorings, \\
built-in metamodel editor, EMF support.  \\ \hline

\textbf{QVTR-XSLT}: \textit{general-purpose model transformations.} \\
Supporting the graphical notation of QVT Relations with a graphical editor \\
to define transformations, and generate executable XSLT programs for them.  \\ \hline

\textbf{UML-RSDS}: \textit{general-purpose model transformation with verification support.} \\
Declarative transformation specification using only UML/OCL. \\
Efficient compiled transformation implementations.  \\ \hline

\textbf{Viatra2}: \textit{general-purpose multi-domain model transformations.} \\
Model space with arbitrary metalevels, excellent programming API. \\
Incremental pattern matching.  \\ \hline
\end{tabular}
\end{center}
\caption{Graph transformation tools and their strong points}
\label{tab:gg_tools}
\end{table}

\section{Research goals}\label{sec:goals}
The motivation above is given for using graph grammars as a modelling technique in Model-Based Testing. The goal of this research is to create a system for automatic test generation on graph grammars. If the assumptions that graph grammars provide a more intuitive modelling and testing process hold, this new testing approach will lead to a more efficient testing process and fewer incorrect models. The system to be designed, once implemented and validated, should provide a valuable contribution to the testing paradigm. 

The backbone of this system consists of two tools: a model-based testing tool for the testing part and a graph transformation tool for visual editing and state-space exploration of Graph Grammars. The choice was made to use ATM as the model-based testing tool, because of the location of Axini, their willingness to support this project and the already available models for case studies. Another interesting option for our research would have been to use an open-source MBT tool. In particular JTorX was an interesting candidate due to its maturity and the available support at the University of Twente. The tools GROOVE and ATM are used to create this system. The graph transformation tool GROOVE\footnote{http://sourceforge.net/projects/groove/} does state-space exploration, has a visual editor and has available support at the University of Twente, therefore it is used to model and explore the graph grammars.

The research goals are split into a design and validation component:
\begin{enumerate}
    \item \textbf{Design}: Design and implement a system using ATM and GROOVE which performs Model-Based Testing on graph grammars.
    \item \textbf{Validation}: Validate the design and implementation using case studies and performance measurements.
\end{enumerate}

The result of the design goal is one system called the GROOVE-Axini Testing System (GRATiS). The validation goal uses case-studies with existing specifications from systems tested by Axini. Each case-study has a graph grammar and a symbolic model which describe the same system. GRATiS and ATM are used for the automatic test generation on these models respectively. Both the models and the test processes are compared as part of the validation.

The solution has to uphold three requirements:
\begin{enumerate}
\item A graph grammar must be used as the model; it must derive from the specification and be used for the testing.
\item It must be possible to measure the test progress/completion, by means of \textit{coverage} statistics (explained in detail in section~\ref{sec:coverage}).
\item The solution must be efficient: it should be usable in practice, therefore the technique should be scalable and the imposed constraints reasonable from a practical view point.
\end{enumerate}

\section{Roadmap}
This report has five more chapters: first, the concepts described in this chapter are elaborated in chapter \ref{chapter:background}. The design of GRATiS is described in chapter \ref{chapter:gg_to_sts}. The implementation of GRATiS is covered in chapter~\ref{chapter:implementation}. The validation of GRATiS is in chapter \ref{chapter:validation}. Finally, conclusions are drawn and future work suggestions are made in chapter \ref{chapter:conclusion}.
