In software development projects, often limited time and resources are available for testing. However, testing is an important part of software development, because it decreases future maintainance costs~\cite{McConnell:testing}. Testing is a complex process and should be done often~\cite{Pol:testing}. Therefore, the testing process should be as efficient as possible in order to save resources.

Test automation allows repeated testing during the development process. The advantage of this is that bugs are found early and can therefore be fixed early.  A widely used practice is maintaining a \textit{test suite}, which is a collection of tests. However, when the creation of a test suite is done manually, this still leaves room for human error~\cite{Blackburn:testing}. Also, manual creation of test-cases is not time-efficient.

Creating an abstract representation or a \textit{model} of the system is a way to tackle these problems. What is meant by a model in this report, is the description of the behavior of a system. Models such as state charts and sequence charts, which only describe the system architecture, are not considered here. A model can be used to systematically generate tests for the system. This is referred to as \textit{model-based testing}. This leads to a larger test suite in a shorter amount of time than if done manually. These models are created from the specification documents provided by the end-user. These specification documents are 'notoriously error-prone'~\cite{McCabe:testing}. If the tester copies an error in the document or makes a wrong interpretation, the constructed model becomes incorrect.

The stakeholders evaluate the constructed model to verify its correctness. However, the visual or textual representation of large models may become troublesome to understand, which is referred to as the model having a low model transparency. The feedback process of the stakeholders is obstructed by low transparency models. Models that are often used are state machines, i.e. a collection of nodes representing the states of the system connected by transitions representing an action taken by the system. The problem in such models with a large amount of states is the decrease of model transparency. Errors in models with a low transparency are not easily detected.

A formalism that among other things can describe software systems is Graph Transformation. The system states are represented by graphs and the transitions between the states are accomplished by applying graph change rules to those graphs. These rules can be expressed as graphs themselves. A graph transformation model of a software system is therefore a collection of graphs, each a visual representation of one aspect of the system. This formalism may therefore provide a more intuitive approach to system modelling. Graph Transformation and its potential benefits have been studied since the early '70s. The usage of this computational paradigm is best described by the following quote from Andries et al.~\cite{Andries1999}: "Graphs are well-known, well-understood, and frequently used means to represent system states, complex objects, diagrams, and networks, like flowcharts, entity-relationship diagrams, Petri nets, and many more. Rules have proved to be extremely useful for describing computations by local transformations: Arithmetic, syntactic, and deduction rules are well-known examples." An informative paper on graph transformations is written by Heckel et al.~\cite{Heckel2006187}. A quote from this paper: "Graphs and diagrams provide a simple and powerful approach to a variety of problems that are typical to computer science in general, and software engineering in particular."

The motivation is given for using graph grammars as a modelling technique. The goal of this research is to create a system for automatic test generation on graph grammars. If the assumptions that graph grammars provide a more intuitive modelling and testing process hold, this new testing approach will lead to a more efficient testing process and fewer incorrect models. The system design, once implemented and validated, provides a valuable contribution to the testing paradigm.

Tools that perform statespace exploration on graph grammars and tools for automatic test generation already exist. One tool for each of these functions will be used in this research. The graph transformation tool GROOVE\footnote{http://sourceforge.net/projects/groove/} will be used to model and explore the graph grammar. The testing tool developed by Axini\footnote{http://www.axini.nl/} is used for the automatic test generation on \textit{symbolic} models, which combine a state and data type oriented approach. This tool will be referred to in this report as Axini Test Manager (ATM).

The structure of the rest of this chapter is as follows: the goals of this research are set out and clarified in section~\ref{sec:goals}. The general model-based testing process is set out in section \ref{sec:model_based_testing}. Some basic concepts from first order logic are described in section~\ref{sec:first_order_logic}, used as a framework for dealing with data in the symbolic models used in ATM. These models are then described in section \ref{sec:symbolic}. Section \ref{sec:graph} describes the graph grammar formalism. GROOVE and ATM are described in section \ref{sec:tooling}. Section~\ref{sec:extended_graph_grammars} describes an extension of graph grammars, as used in GROOVE.
