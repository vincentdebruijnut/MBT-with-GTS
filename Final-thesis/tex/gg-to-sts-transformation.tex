\section{Requirements considerations}
In order to do model-based testing with GGs, stimuli and responses have to be obtained from the GG. ATM uses an IOSTS, where the instantiated switch relations represent a stimulus to or a response from the SUT. To get an equivalent notion of stimuli/respones in GGs, the GG must be extended to an IOGG by indicating for each transformation rule whether it is of the input or output type. Then the IOGG can be explored to an IOGTS. The input/output rule transitions of the IOGTS can be used as the abstract stimuli and responses.

The second requirement for the design is the possibility to measure coverage statistics. The exploration of a GG can be done in two ways: \textit{on the fly}, rule transitions are explored only when chosen by ATM, or \textit{offline}, the GG is first completely explored and then sent to ATM. On-the-fly model exploration works well on large and even infinite models. However, coverage statistics cannot be calculated with this technique. The number of states (graphs) and rule transitions the model has when completely explored are not known, so a percentage cannot be derived. As coverage statistics are an important metric, the offline model exploration is chosen for GRATiS.

The last requirement is efficiency. An IOGTS can potentially be infinitely large, due to the range of data values. A model that is more efficient with data values is an STS. The setup of GRATiS is therefore to transform the IOGG directly to an IOSTS. Note that the first requirement is met, because locaton and switch relation coverage can be calculated on the IOSTS.

Taking these requirements into account, the method to achieve the goal of model-based testing on GGs is the following three steps:
\begin{enumerate}
\item Assign I/O types to graph transformation rules
\item Create an IOSTS from the IOGG
\item Perform the model-based testing on the IOSTS
\end{enumerate}
This chapter describes an algorithm for creating an IOSTS from an IOGG.

\section{Point algebra}
We define a \textit{point algebra} $\PointAlgebra$\newnot{symbol:PointAlgebra} to be an algebra with $\forall \sort \in \Sorts . |\mathbb{U}_\PointAlgebra^\sort| = 1$. Each graph in $\Graphs$ using the point algebra is structurally unique upto isomorphism; different values on value nodes are eliminated by the point algebra and two structurally equivalent graphs are the same graph. Therefore, using this algebra is efficient when exploring the GTS. The loss of information is only in the concrete values at each state. This information is also not present in an STS, which treats the values symbolically as variables.

\section{Variables}
The variables in an STS represent an aspect of the modelled system. For instance, if a system keeps track of the number of items in containers, the STS modelling this system could have integer location variables $\mathit{items}_1..\mathit{items}_n$. The value nodes in a host graph are a representation of one element from the universe of elements of the same sort. Edges can exist between graph nodes and value nodes. The same example modelled in a graph grammar could be a graph node representing a container with an edge labelled 'items' to an integer node. This is shown in Figure~\ref{fig:item_example}. This is a common way of representing a variable in a GG. Here the combination of edge plus source node represents the variable. However, the source node identity is not consistent through graph transformations, as the graphs are structurally unique upto isomorphism. In order to have variables in GGs, the source node must be made structurally unique, by means of a self-edge. Figure~\ref{fig:item_example2} shows the self-edge on the container node. The variable $\mathit{var1\_items}$, the number of items in the container, is now represented by this graph.

\begin{figure}[ht]
  \begin{center}
    \subfloat[Common way]{\label{fig:item_example}\parbox[b]{4cm}{\input{./img/item_example.tex}}}
    \subfloat[Persistent way]{\label{fig:item_example2}\parbox[b]{4cm}{\input{./img/item_example2.tex}}}
  \end{center}
  \caption{Possible ways of modelling variables in GGs}
  \label{fig:vars-in-ggs}
\end{figure}

On the basis of the discussion above, we introduce the following terminology. The labels on the self-edges we call \textit{variable labels}, represented by $\Labels_{var}$. The edge having a variable label we call a \textit{variable edge}. The source and target node of the variable edge we call the \textit{variable anchor}.

\section{The algorithm}
Let $J = \langle \Locations,\initialLocation,\LocationVariables,\initializationFunction,\InteractionVariables,\Gates,\Switches\rangle$ be an IOSTS and let $K = \langle \Rules, \startGraph \rangle$ be an IOGG. The first step in the algorithm is to explore the GG $K$ using the point algebra $\PointAlgebra$ to an IOGTS $O_\PointAlgebra: \langle \hostGraph, \Rules, \RuleMatches, \RuleTransitions, \startGraph \rangle$.

\subsection{Locations}
The set of locations $\Locations$ is chosen to be equal to the set of graphs $\hostGraph$. Additionally, the initial location $\initialLocation$ is equal to the initial graph $\startGraph$.

\subsection{Location variables}
The location variables are a subset of the product of variable labels and regular labels, given by $\LocationVariables \subset \Labels_{var} \times \Labels$. The set of location variables in a host graph $\langle \DefinedNodes, \DefinedEdges\rangle$ is defined by the following. $\langle \ltsLabel_{var}, \ltsLabel \rangle \in \LocationVariables$ if:
\begin{itemize}
\item $\langle w \in \mathbb{W}, \ltsLabel, u \in \mathbb{U} \rangle \in \DefinedEdges$ - the label must be on an edge from a graph node to a value node.
\item $\langle w, \ltsLabel_{var}, w \rangle \in \DefinedEdges$ - the variable label must be a self edge on the same graph node.
\end{itemize}
The initialization $\initializationFunction$ is then given by $\langle \ltsLabel_{var}, \ltsLabel \rangle \mapsto u$.

\subsection{Gates}
The gate of a switch relation represents the stimulus to or response from the SUT. In an IOGG, the rules are this representation. Therefore, the set of gates $\Gates$ is chosen to be equal to the set of rules $\Rules$.

\subsection{Interaction variables}
Interaction variables are used by the gates to represent a stimulus or response variable. The variable nodes in rule graphs are this representation. The set of interaction variables $\InteractionVariables$ is chosen to be equal to the set of variable nodes $\Variables$. For a rule $\ggrule$ and all variable nodes $\Variables_\ggrule$ in $\mathit{LHS}$ of $\ggrule$, $arity(\ggrule) = |\Variables_\ggrule|$. %The arity will always be greater than or equal to the required amount. Figure~\ref{fig:item-example3} shows the $\mathit{LHS}$ of a rule for the container-item example. This rule adds one item to the container. The interaction variables here would be the old number of items in the container and the new number. 

\subsection{Guards}\label{sec:guards}
The guard of a switch relation restricts the use of the switch relation based on the values of the variables. In a GG, a rule is restricted by the terms. The variables used in the terms are interaction variables. Therefore, the first part of the guard is constructed by joining the terms for each term node by $\bigwedge_{\node \in \DefinedRuleNodes \cap \TermNodes}\bigwedge_{t_1, t_2 \in \node}t_1 = t_2$. Using a rule match $\rulematch$, the second part is constructed. For a $\mathit{LHS} = \langle \DefinedRuleNodes, \DefinedRuleEdges\rangle$ the smallest set of terms $T$, such that $\langle \rulematch(\node), \ltsLabel \rangle = x \in T$ when:
\begin{itemize}
\item $x \in \Variables \cap \DefinedRuleNodes$
\item $\langle \node, \ltsLabel, x\rangle \in \DefinedRuleEdges$
\item $\rulematch(\node)$ is a variable anchor
\end{itemize}
Then, the terms are joined by $\bigwedge_{t\in T}t$.

\subsection{Update mappings}\label{sec:updates}
An edge with label $\ltsLabel$ from a variable anchor $\node$ to a value node can be erased from the graph and a new edge with label $\ltsLabel$ from $\node$ to a new value node can be created by a rule. This inidicates an update for the location variable given by $\langle \node, \ltsLabel \rangle$. In the rule graph, the $\mathit{RHS}$ of the rule has the pre-image of the $\node$ and the edge to a variable node, given by the interaction variable $x$. The update mapping for this example is: $\langle \node, \ltsLabel \rangle \mapsto x$.

\subsection{Switch relations}
A rule transition $\hostGraph \xrightarrow{\ggrule, \rulematch} \hostGraph' \in \RuleTransitions$ is mapped to a switch relation $(\hostGraph\xrightarrow{\ggrule, \guard, \updateMapping}\hostGraph') \in \Switches$. The guard and update mapping are constructed according to sections~\ref{sec:guards} and \ref{sec:updates} using $\ggrule$ and $\rulematch$.

