\section{Requirements considerations}
From the research goals we derive three high level requirements:
\begin{enumerate}
\item The system should be able to perform model-based testing on GGs
\item The system should be validated so it should allow coverage metrics to be measured, because as seen in the previous chapter, coverage statistics are a useful and objective metric to describe how much of the model is tested
\item The system should be validated using case studies so it should be efficient enough to handle large models
\end{enumerate}

\paragraph*{IOGGs} In order to fulfill the first requirement, stimuli and responses have to be obtained from a GG. ATM uses an IOSTS, where the instantiated switch relations represent a stimulus to or a response from the SUT. GGs have no notion of inputs and outputs, therefore IOGGs have to be used as the model formalism. IOGGs can be explored to IOGTSs and the I/O labels of the IOGTS can be used to represent abstract stimuli/responses.

\paragraph*{On-the-fly vs. Offline exploration} The exploration of a GG can be done in two ways: \textit{on the fly}, rule transitions are explored only when chosen by ATM, or \textit{offline}, the GG is first completely explored and then sent to ATM. On-the-fly model exploration works well on large and even infinite models. However, coverage statistics cannot be calculated with this technique. The number of states (graphs) and rule transitions the model has when completely explored are not known, so a percentage cannot be derived. As coverage statistics are an important metric, the offline model exploration is chosen for GRATiS.

\paragraph*{Data values} An IOGTS can potentially be infinitely large, due to the range of data values. This is a potential risk for the validation of the system. A model that is more efficient with data values is an STS. The setup of GRATiS is therefore to transform the IOGG directly to an IOSTS. This transformation should be done efficiently to fulfill the third requirement. Note that the second requirement is still met, because location and switch relation coverage can be calculated on the IOSTS.

\paragraph*{} Taking these requirements into account, the method to achieve the goal of model-based testing on GGs is the following three steps:
\begin{enumerate}
\item Create an IOGG by assigning I/O types to the graph transformation rules of a GG
\item Create an IOSTS from the IOGG
\item Perform the model-based testing on the IOSTS
\end{enumerate}
The rest of this chapter describes a declaritive definition for creating an IOSTS from an IOGG.

\section{From IOGG to IOSTS}\label{sec:algorithm}
\subsection{Variables in GGs} 
The location variables in an STS represent an aspect of the modelled system. For instance, if a system keeps track of the number of items in containers, the STS modelling this system could have integer location variables $\mathit{items}_1..\mathit{items}_n$. GGs do not have this kind of variables. The variable nodes in rule graphs are used to match a value in a host graph, which is only available to that rule. A definition of persistent variables in GGs is needed in order to define location variables from an IOGG.

\vspace{10px}
\begin{definition} GG variables \\
A GG variable is a 3-tuple $\langle \variableAnchor, \variableEdge, \valueEdge\rangle$, where:
\begin{itemize}
\item \newnot{symbol:variableAnchor}$\variableAnchor \in \DefinedNodes\backslash\mathbb{U}$ is the \textit{variable anchor}.
\item \newnot{symbol:variableEdge}$\variableEdge \in \{\variableAnchor\} \times \Labels \times \{\variableAnchor\}$ is a self-edge of the variable anchor, called the \textit{variable edge}.
\item \newnot{symbol:valueEdge}$\valueEdge \in \{\variableAnchor\} \times \Labels \times \mathbb{U}\rangle$ is an edge from the variable anchor to a value node, called the \textit{value edge}.
\end{itemize}
\end{definition}
\vspace{10px}

The item/container example modelled in a graph grammar could be a graph node representing a container with an edge labelled `items' to an integer node. This is shown in Figure~\ref{fig:gg_vars_formal}. Using the labels of the variable anchor, variable edge and value edge, the variable $\langle \mathit{container, var1, items}\rangle$ is now represented by this graph. Figure~\ref{fig:gg_vars_groove} shows the same example in GROOVE. The variable edge is represented here by the flag \textit{var1}. Variable edges are represented by flags in GROOVE in the rest of this report. 

\begin{figure}[ht]
  \begin{center}
    \subfloat[Formal]{\label{fig:gg_vars_formal}\parbox[b]{4cm}{\centering\input{./img/item_example2.tex}}}
    \subfloat[GROOVE]{\label{fig:gg_vars_groove}\parbox[b]{4cm}{\centering\input{./img/gg_variable.tikz}}}
  \end{center}
  \caption{Example of a GG variable}
  \label{fig:vars-in-ggs}
\end{figure}

\subsection{Graph exploration with point algebra} 
The IOGG cannot be directly made into an IOSTS, without using the IOGTS. To avoid the problem of a potentially infinitely large IOGTS, the point algebra is used. Using the point algebra when exploring a GG has two effects:
\begin{enumerate}
\item The host graphs that differ only in value nodes are collapsed into one
\item The variable nodes in rule graphs can have at most one image in the host graph
\end{enumerate}

\subsection{The IOGG to IOSTS definition} 
First the declaritive definition is given, then each part of the definition is described in more detail.
\vspace{10px}
\begin{definition} IOGG to IOSTS \\
Let $K$ be an IOGG. From $K$ we define an IOSTS $J$. The first step is to explore $K$ using the point algebra $\PointAlgebra$ to an IOGTS $O_\PointAlgebra$. The elements of $J$ can be obtained as follows:
\begin{itemize}
\item $\Locations = \Graphs$
\item $\initialLocation = \startGraph$
\item $\LocationVariables = \GGVariables$
\item $\Gates = \Rules$
\item $\InteractionVariables = \Variables$
\item $\Switches = \RuleTransitions$
\item guard
\item update mapping\marginpar{finish this list}
\end{itemize}
\end{definition}

\paragraph*{Locations} The locations abstract from data values, exactly like host graphs do under the point algebra. Therefore, the set of locations in $J$ are the set of host graphs in $O_\PointAlgebra$. The initial location in $J$ is also equal to the start graph of $O_\PointAlgebra$.

\paragraph*{Location variables} GG variables were defined to have location variables in GGs. Therefore, it is no surprise that the set of location variables in $J$ is exactly the set of GG variables in $O_\PointAlgebra$. This poses some constraints on creators/erasers for the variable anchors, variable edges and value edges. This is explained in detail in section~\ref{sec:constraints}.

\paragraph*{Gates}
The gate of a switch relation represents the stimulus to or response from the SUT. In an IOGG, the rules represent the stimuli and responses. Therefore, the set of gates $\Gates$ is chosen to be equal to the set of rules $\Rules$.

\paragraph*{Interaction variables}
Interaction variables are used by the gates to represent a stimulus or response variable. The variable nodes in rule graphs are this representation. The set of interaction variables $\InteractionVariables$ is chosen to be equal to the set of variable nodes $\Variables$. For a rule $\ggrule$ and all variable nodes $\Variables_\ggrule$ in $\mathit{LHS}$ of $\ggrule$, $arity(\ggrule) = |\Variables_\ggrule|$. \marginpar{need to define variable anchors in a graph, or variable labels in a graph}

\paragraph*{Switch relations}
A rule transition $\hostGraph \xrightarrow{\ggrule, \rulematch} \hostGraph' \in \RuleTransitions$ is mapped to a switch relation $(\hostGraph\xrightarrow{\ggrule, \guard, \updateMapping}\hostGraph') \in \Switches$. The guard and update mapping are constructed according to sections~\ref{sec:guards} and \ref{sec:updates} using $\ggrule$ and $\rulematch$. 

\paragraph*{Guard}\label{sec:guards}
The guard of a switch relation restricts the use of the switch relation based on the values of the variables. In a GG, a rule is restricted by the terms.\marginpar{need to define the term nodes in a graph} The variables used in the terms are interaction variables. Therefore, the first part of the guard is constructed by joining the terms for each term node by $\bigwedge_{\node \in \DefinedRuleNodes \cap \TermNodes}\bigwedge_{t_1, t_2 \in \node}t_1 = t_2$. Using a rule match $\rulematch$, the second part is constructed. For a $\mathit{LHS} = \langle \DefinedRuleNodes, \DefinedRuleEdges\rangle$ let $T$ be the smallest set of terms, such that $\langle \rulematch(\node), \ltsLabel \rangle = x \in T$ when:
\begin{itemize}
\item $x \in \Variables \cap \DefinedRuleNodes$
\item $\langle \node, \ltsLabel, x\rangle \in \DefinedRuleEdges$
\item $\rulematch(\node)$ is a variable anchor
\end{itemize}
Then, the terms are joined by $\bigwedge_{t\in T}t$.

\paragraph*{Update mapping}\label{sec:updates}
An edge with label $\ltsLabel$ from a variable anchor $\node$ to a value node can be erased from the graph and a new edge with label $\ltsLabel$ from $\node$ to a new value node can be created by a rule. This inidicates an update for the location variable given by $\langle \node, \ltsLabel \rangle$.\marginpar{make consistent with variable definition} In the rule graph, the $\mathit{RHS}$ of the rule has the pre-image of the $\node$ and the edge to a variable node, given by the interaction variable $x$. The update mapping for this example is: $\langle \node, \ltsLabel \rangle \mapsto x$.

\section{Rule priority}\marginpar{explain this clearer.}
This section covers a specific implementation issue of setting rule priorities in GROOVE.

The graphs are isomorphic under the point algebra, so they represent the same location. The STS of transforming this graph grammar is in Figure~\ref{fig:priority_sts_wrong}, with $\imath = \{x \mapsto 25\}$. This STS is wrong, because the 'sub' switch relation can be taken from the start.

\begin{figure}[ht]
  \begin{center}
    \input{./img/priority_sts_wrong.tex}
  \end{center}
  \caption{A wrong STS transformation of the graph grammar in Figure~\ref{fig:priority_gg}}
  \label{fig:priority_sts_wrong}
\end{figure}

The solution is shown in Figure~\ref{fig:priority_sts_right}. The negated guard of the 'add' switch relation is added to the 'sub' switch relation. The optimized guard for this switch relation is 'x >= 30' of course, but this shows the main principle: for each outgoing switch relation, the negated guard of all switch relations represented by higher priority rules must be added to the guard. So, the 'x < 30' guard is negated to '!(x < 30)' and added to yield the 'x > 10 \&\& !(x < 30)' guard. Note that if the 'add' switch relation had no guard, it would be applicable on all graph states with isomorphic abstractions. Therefore, the 'sub' switch relation would not exist, because the 'add' rule is always applicable whenever the 'sub' rule also is.

\begin{figure}[ht]
  \begin{center}
    \input{./img/priority_sts_right.tex}
  \end{center}
  \caption{A correct STS transformation of the graph grammar in Figure~\ref{fig:priority_gg}}
  \label{fig:priority_sts_right}
\end{figure}

