\section{Introduction}\label{sec:introduction}
In software development projects, often limited time and resources are available for testing. However, testing is an important part of software development, because it decreases future maintainance costs~\cite{McConnell:testing}. Testing is a complex process and should be done often~\cite{Pol:testing}. Therefore, the testing process should be as efficient as possible in order to save resources.

Test automation allows repeated testing during the development process. The advantage of this is that bugs are found early and can therefore be fixed early.  A widely used practice is maintaining a \textit{test suite}, which is a collection of tests. However, when the creation of a test suite is done manually, this still leaves room for human error~\cite{Blackburn:testing}. Also, manual creation of test-cases is not time-efficient.

Creating an abstract representation or a \textit{model} of the system is a way to tackle these problems. What is meant by a model in this report, is the description of the behavior of a system. Models such as state charts and sequence charts, which only describe the system architecture, are not considered here. A model can be used to systematically generate tests for the system. This is referred to as \textit{model-based testing}. This leads to a larger test suite in a shorter amount of time than if done manually. These models are created from the specification documents provided by the end-user. These specification documents are 'notoriously error-prone'~\cite{McCabe:testing}. If the tester copies an error in the document or makes a wrong interpretation, the constructed model becomes incorrect.

The stakeholders evaluate the constructed model to verify its correctness. However, the visual or textual representation of large models may become troublesome to understand, which is referred to as the model having a low model transparency. The feedback process of the stakeholders is obstructed by low transparency models. Models that are often used are state machines, i.e. a collection of nodes representing the states of the system connected by transitions representing an action taken by the system. The problem in such models with a large amount of states is the decrease of model transparency. Errors in models with a low transparency are not easily detected.

A formalism that among other things can describe software systems is Graph Transformation. The system states are represented by graphs and the transitions between the states are accomplished by applying graph change rules to those graphs. These rules can be expressed as graphs themselves. A graph transformation model of a software system is therefore a collection of graphs, each a visual representation of one aspect of the system. This formalism may therefore provide a more intuitive approach to system modelling. Graph Transformation and its potential benefits have been studied since the early '70s. The usage of this computational paradigm is best described by the following quote from Andries et al.~\cite{Andries1999}: "Graphs are well-known, well-understood, and frequently used means to represent system states, complex objects, diagrams, and networks, like flowcharts, entity-relationship diagrams, Petri nets, and many more. Rules have proved to be extremely useful for describing computations by local transformations: Arithmetic, syntactic, and deduction rules are well-known examples." An informative paper on graph transformations is written by Heckel et al.~\cite{Heckel2006187}. A quote from this paper: "Graphs and diagrams provide a simple and powerful approach to a variety of problems that are typical to computer science in general, and software engineering in particular."

\subsection{Research setup}
This report describes the setup of a project where the use of Graph Grammars in model-based testing is researched. In the introduction the motivation is given for using this type of modelling technique. The goal is to create a system for automatic test generation on Graph Grammars. If the assumptions that Graph Grammars provide a more intuitive modelling and testing process hold, this new testing approach will lead to a more efficient testing process and fewer incorrect models. The system design, once implemented and validated, provides a valuable contribution to the testing paradigm.

Tools that perform statespace exploration on Graph Grammars and tools for automatic test generation already exist. Two of these tools will be used to perform these functions. The graph transformation tool GROOVE\footnote{http://sourceforge.net/projects/groove/} will be used to model and explore the Graph Grammar. The testing tool developed by Axini\footnote{http://www.axini.nl/} is used for the automatic test generation on \textit{symbolic} models, which combine a state and data type oriented approach. This tool will be referred to in this report as Axini Test Manager (ATM).

\subsection{Research questions}\label{sec:questions}
The research questions are split into a design and validation component:
\begin{enumerate}
    \item \textbf{Design}: How can automatic test generation be done using graph transformation systems? In particular, how can ATM be used together with GROOVE to achieve this?
    \item \textbf{Validation}: What are the strengths and weaknesses of using graph transformation systems in model-based testing?
\end{enumerate}

The result of the design question will be one system which incorporates ATM and GROOVE. This system will be referred to as the GROOVE-Axini Testing System (GRATiS). In order to answer the first research question sufficiently, GRATiS should produce tests on the basis of a Graph Grammar and give correct verdicts whether the system contains errors or not.

The criteria used to assess the strengths and weaknesses are split into two parts: the objective and the subjective criteria. The objective criteria are the measurements that can be done on GRATiS, such as speed and statespace size. The subjective criteria are related to how easy graph transformation models are to use and maintain. The assessment of the latter criteria requires a human component. The criteria and methods for the assessment are elaborated in section \ref{sec:research_methods_validation}.

GRATiS will be validated using case-studies. These case-studies are done with existing specifications from systems tested by Axini. Each case-study will have a Graph Grammar and a symbolic model which describe the same system. GRATiS and ATM are used for the automatic test generation on these models respectively. Both the model and the test process will then be compared as part of the validation. This includes the criteria mentioned in this section. This is explained in more detail in section~\ref{sec:research_methods_validation}.

\subsection{Structure of the report}
The structure of this document is as follows: the general model-based testing process is set out in section \ref{sec:model_based_testing}. Some basic concepts from first order logic are described in section~\ref{sec:first_order_logic}, used as a framework for dealing with data in the symbolic models used in ATM. These models are then described in section \ref{sec:symbolic}. Section \ref{sec:graph} describes Graph Grammars used in GROOVE. GROOVE and ATM are described in section \ref{sec:tooling}. The method used to answer the research questions above is in section \ref{sec:research_methods}. Finally, the planning for the project is in appendix \ref{app:planning}.
